local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/Library.lua"))()
local ThemeManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/addons/SaveManager.lua"))()

-- Lista completa de passivas por m√°quina
local AllPassives = {
    ["Normal"] = {
        "Dmg1", "Dmg2", "Dmg3",
        "Boss1", "Boss2", "Boss3", 
        "Drop1", "Drop2", "Drop3",
        "Yen1", "Yen2", "Yen3",
        "LevelUp1", "LevelUp2", "LevelUp3",
        "Ability1", "Ability2", "Ability3",
        "Leader1", "Leader2", "Leader3",
        "Luck1", "Luck2", "Luck3", "Luck4",
        "Cap1", "Cap2", "Cap3",
        "Speed", "Giant", "Tiny", "Tank", "Blessing",
        "Gold", "Merc", "Dragon", "Prodigy", "Ghost", "Ace",
        "Demon", "BrokenLimiter", "Angel", "Interstellar"
    },
    ["Summer24"] = {
        "SeaSpearman", "DevastatingDaylight", "SummerFortune",
        "SapphireSummer", "SummerGenerosity", "ShiningSun", "CoralCommander"
    }
}
AllPassives["Requiem"] = AllPassives["Normal"]

-- Store initialization
local LocalDairebStore, GameData
local success, error = pcall(function()
    LocalDairebStore = require(game:GetService("ReplicatedStorage").ModuleScripts.LocalDairebStore)
    LocalDairebStore:WaitForInit()
    GameData = LocalDairebStore.GetStoreProxy("GameData")
end)

if not success then
    Library:Notify("‚ùå Erro ao carregar GameData: " .. tostring(error), 10)
    return
end

-- HasPassive module (optional)
local HasPassive = nil
pcall(function()
    HasPassive = require(game:GetService("ReplicatedStorage").ModuleScripts.HasPassive)
end)

-- PassiveStats module for validation
local PassiveStats = nil
pcall(function()
    PassiveStats = require(game:GetService("ReplicatedStorage").ModuleScripts.PassiveStats)
end)

-- Global variables
local selectedUnit, selectedMachine = nil, "Normal"
local selectedPassives = {}
local rolling = false
local rollDelay = 1.0
local rollCount = 0
local autoRollToggle = nil

-- Detection configuration - OTIMIZADO baseado no seu c√≥digo
local detectionConfig = {
    baseDelay = 2.5,        -- Delay inicial reduzido
    maxRetries = 5,         -- Mais tentativas
    retryDelay = 0.8,       -- Delay menor entre tentativas
    enabled = false
}

-- ===== CORE FUNCTIONS =====

-- Get current unit data - MELHORADO
local function getCurrentUnit()
    local success, result = pcall(function()
        local gameData = GameData:GetData()
        if not gameData or not gameData.Pets then return nil end
        
        for _, unit in pairs(gameData.Pets) do
            if unit and unit.UID == selectedUnit then
                return unit
            end
        end
        return nil
    end)
    
    return success and result or nil
end

-- NOVA FUN√á√ÉO: Validar se passiva existe no PassiveStats
local function isValidPassive(passiveName)
    if not PassiveStats or not passiveName then return false end
    return PassiveStats[passiveName] ~= nil
end

-- FUN√á√ÉO MELHORADA: Convers√£o de passiva mais permissiva
local function passiveToString(passive)
    if passive == nil then return nil end
    
    -- Aceitar strings diretamente
    if type(passive) == "string" and passive ~= "" and passive ~= "nil" then 
        return passive 
    end
    
    -- Converter n√∫meros
    if type(passive) == "number" then 
        return tostring(passive) 
    end
    
    -- Tentar converter outros tipos
    local str = tostring(passive)
    if str and str ~= "" and str ~= "nil" and str ~= "false" and str ~= "true" then
        return str
    end
    
    return nil
end

-- FUN√á√ÉO MELHORADA: HasPassive com mais m√©todos
local function checkHasPassive(unit, passiveName)
    if not HasPassive or not unit or not passiveName then 
        return false 
    end
    
    -- Lista de m√©todos poss√≠veis para tentar
    local methods = {
        -- M√©todo direto
        function() return HasPassive(unit, passiveName) end,
        -- M√©todo com .HasPassive
        function() return HasPassive.HasPassive(unit, passiveName) end,
        -- M√©todo com .Check
        function() return HasPassive.Check(unit, passiveName) end,
        -- M√©todo com UID
        function() return HasPassive(unit.UID, passiveName) end,
        -- M√©todo com passiva como objeto
        function() 
            if unit.Passives then
                for _, passive in pairs(unit.Passives) do
                    if passiveToString(passive) == passiveName then
                        return HasPassive(unit, passive)
                    end
                end
            end
            return false
        end
    }
    
    for i, method in ipairs(methods) do
        local success, result = pcall(method)
        if success and result then
            print("‚úÖ HasPassive m√©todo " .. i .. " encontrou: " .. passiveName)
            return true
        end
    end
    
    return false
end

-- FUN√á√ÉO MELHORADA: Detec√ß√£o manual mais robusta
local function checkPassivesManual(unit, desiredPassives)
    if not unit or not unit.Passives or not desiredPassives then 
        return false, nil 
    end
    
    print("üîç Detec√ß√£o manual - Passivas da unit:")
    
    -- Coletar todas as passivas atuais
    local currentPassives = {}
    local passiveCount = 0
    
    for i, passive in pairs(unit.Passives) do
        local passiveStr = passiveToString(passive)
        if passiveStr then
            currentPassives[passiveStr] = true
            passiveCount = passiveCount + 1
            print("  [" .. i .. "] " .. passiveStr .. " ‚úÖ")
            
            -- Validar se √© uma passiva real
            if isValidPassive(passiveStr) then
                print("    ‚îî‚îÄ Passiva v√°lida no PassiveStats")
            else
                print("    ‚îî‚îÄ ‚ö†Ô∏è Passiva n√£o encontrada no PassiveStats")
            end
        else
            print("  [" .. i .. "] " .. tostring(passive) .. " ‚ùå (ignorado)")
        end
    end
    
    print("üìä Total de passivas v√°lidas: " .. passiveCount)
    print("üéØ Procurando por:")
    
    -- Verificar cada passiva desejada
    for _, desired in pairs(desiredPassives) do
        local desiredStr = tostring(desired)
        print("  - " .. desiredStr)
        
        -- Verifica√ß√£o direta
        if currentPassives[desiredStr] then
            print("üéâ ENCONTRADA (exata): " .. desiredStr)
            return true, desiredStr
        end
        
        -- Verifica√ß√£o parcial (case insensitive)
        for currentPassive, _ in pairs(currentPassives) do
            if string.lower(currentPassive) == string.lower(desiredStr) then
                print("üéâ ENCONTRADA (case insensitive): " .. currentPassive)
                return true, currentPassive
            end
        end
        
        -- Verifica√ß√£o por substring
        for currentPassive, _ in pairs(currentPassives) do
            if string.find(string.lower(currentPassive), string.lower(desiredStr)) or 
               string.find(string.lower(desiredStr), string.lower(currentPassive)) then
                print("üéâ ENCONTRADA (substring): " .. currentPassive)
                return true, currentPassive
            end
        end
    end
    
    return false, nil
end

-- FUN√á√ÉO PRINCIPAL: Detec√ß√£o com retry melhorado
local function detectDesiredPassive()
    if not detectionConfig.enabled or not selectedUnit or not selectedPassives or not next(selectedPassives) then
        return false
    end
    
    print("\nüîç === DETEC√á√ÉO ROLL #" .. rollCount .. " ===")
    
    -- Tentar detec√ß√£o m√∫ltiplas vezes
    for attempt = 1, detectionConfig.maxRetries do
        print("üîÑ Tentativa " .. attempt .. "/" .. detectionConfig.maxRetries)
        
        -- Obter dados da unit
        local currentUnit = getCurrentUnit()
        if not currentUnit then
            print("‚ùå Unit n√£o encontrada, tentando novamente...")
            task.wait(detectionConfig.retryDelay)
            continue
        end
        
        print("‚úÖ Unit encontrada: " .. tostring(currentUnit.UID))
        
        -- M√©todo 1: HasPassive (se dispon√≠vel)
        if HasPassive then
            print("üì° Testando HasPassive...")
            for _, desiredPassive in pairs(selectedPassives) do
                if checkHasPassive(currentUnit, desiredPassive) then
                    print("üéâ SUCESSO via HasPassive: " .. desiredPassive)
                    return true
                end
            end
            print("‚ùå HasPassive n√£o encontrou nenhuma")
        else
            print("‚ö†Ô∏è HasPassive n√£o dispon√≠vel")
        end
        
        -- M√©todo 2: Detec√ß√£o manual (sempre executar)
        print("üîç Executando detec√ß√£o manual...")
        local found, foundPassive = checkPassivesManual(currentUnit, selectedPassives)
        if found then
            print("üéâ SUCESSO via Manual: " .. foundPassive)
            return true
        end
        
        -- Se n√£o √© a √∫ltima tentativa, aguardar
        if attempt < detectionConfig.maxRetries then
            print("‚è≥ Aguardando " .. detectionConfig.retryDelay .. "s antes da pr√≥xima tentativa...")
            task.wait(detectionConfig.retryDelay)
        end
    end
    
    print("‚ùå Nenhuma passiva desejada encontrada ap√≥s " .. detectionConfig.maxRetries .. " tentativas")
    return false
end

-- Stop the rolling system
local function stopRolling(reason)
    rolling = false
    detectionConfig.enabled = false
    
    if autoRollToggle then
        pcall(function() autoRollToggle:SetValue(false) end)
    end
    
    print("üõë PARADO: " .. tostring(reason))
    Library:Notify("üõë " .. reason, 5)
end

-- Update passive display in UI
local function updatePassiveDisplay(unit)
    if not unit or not unit.Passives then
        pcall(function() currentPassivesLabel:SetText("Passivas: N/A") end)
        return
    end
    
    local passiveList = {}
    for _, passive in pairs(unit.Passives) do
        local passiveStr = passiveToString(passive)
        if passiveStr then
            table.insert(passiveList, passiveStr)
        end
    end
    
    local displayText = "Passivas: " .. (#passiveList > 0 and table.concat(passiveList, ", ") or "Nenhuma")
    pcall(function() currentPassivesLabel:SetText(displayText) end)
end

-- Get list of available units
local function GetUnits()
    local success, result = pcall(function()
        local gameData = GameData:GetData()
        if not gameData or not gameData.Pets then
            return {"Nenhum pet encontrado"}
        end
        
        local list = {}
        for _, unit in pairs(gameData.Pets) do
            if unit and unit.UID then
                local displayName = unit.PetId or "Unknown"
                if unit.CustomName and unit.CustomName ~= "" then
                    displayName = displayName .. " (" .. unit.CustomName .. ")"
                end
                table.insert(list, tostring(unit.UID) .. " | " .. displayName)
            end
        end
        
        return #list > 0 and list or {"Nenhum pet encontrado"}
    end)
    
    return success and result or {"Erro ao carregar pets"}
end

-- ===== UI SETUP =====

local Window = Library:CreateWindow({ 
    Title = "Luvwas Passive Roll", 
    Center = true, 
    AutoShow = true 
})

local Tabs = { 
    Main = Window:AddTab("Main"),
    Debug = Window:AddTab("Debug"),
    Settings = Window:AddTab("Settings")
}

local LeftGroup = Tabs.Main:AddLeftGroupbox("Configura√ß√£o")
local RightGroup = Tabs.Main:AddRightGroupbox("Controles")
local StatusGroup = Tabs.Main:AddRightGroupbox("Status")
local DebugGroup = Tabs.Debug:AddLeftGroupbox("Debug & Test")

-- Status indicators
StatusGroup:AddLabel("GameData: " .. (GameData and "‚úÖ OK" or "‚ùå Erro"))
StatusGroup:AddLabel("HasPassive: " .. (HasPassive and "‚úÖ Dispon√≠vel" or "‚ö†Ô∏è Manual apenas"))
StatusGroup:AddLabel("PassiveStats: " .. (PassiveStats and "‚úÖ Dispon√≠vel" or "‚ö†Ô∏è N√£o dispon√≠vel"))
local rollStatusLabel = StatusGroup:AddLabel("Status: Aguardando")
local currentPassivesLabel = StatusGroup:AddLabel("Passivas: N/A")

-- Unit selection
local unitDropdown = LeftGroup:AddDropdown("UnitSelect", {
    Values = GetUnits(),
    Multi = false,
    Text = "Selecione o Boneco",
    AllowNull = true,
    Search = true,
})

unitDropdown:OnChanged(function(val)
    if val and not val:find("Erro") and not val:find("Nenhum") then
        selectedUnit = tonumber(val:match("^(%d+)"))
        Library:Notify("‚úÖ Unit selecionada: " .. tostring(selectedUnit), 2)
        
        -- Show current passives
        local unit = getCurrentUnit()
        updatePassiveDisplay(unit)
    else
        selectedUnit = nil
        pcall(function() currentPassivesLabel:SetText("Passivas: N/A") end)
    end
end)

LeftGroup:AddButton("üîÑ Atualizar Lista", function()
    unitDropdown:SetValues(GetUnits())
end)

-- Machine selection
local machineDropdown = LeftGroup:AddDropdown("MachineSelect", {
    Values = {"Normal","Requiem","Summer24"},
    Default = "Normal",
    Multi = false,
    Text = "M√°quina",
})

-- Passive selection
local passiveDropdown = LeftGroup:AddDropdown("PassiveSelect", {
    Values = AllPassives["Normal"],
    Default = {},
    Multi = true,
    Text = "Passivas Desejadas",
})

machineDropdown:OnChanged(function(val)
    selectedMachine = val
    passiveDropdown:SetValues(AllPassives[val] or AllPassives["Normal"])
    passiveDropdown:SetValue({})
    selectedPassives = {}
    print("üîÑ M√°quina alterada para: " .. val)
end)

passiveDropdown:OnChanged(function(vals)
    selectedPassives = {}
    
    if vals then
        if type(vals) == "table" then
            -- M√©todo 1: ipairs
            for i, passive in ipairs(vals) do
                if type(passive) == "string" and passive ~= "" then
                    table.insert(selectedPassives, passive)
                end
            end
            
            -- M√©todo 2: pairs (caso ipairs n√£o funcione)
            if #selectedPassives == 0 then
                for k, passive in pairs(vals) do
                    if type(passive) == "string" and passive ~= "" then
                        table.insert(selectedPassives, passive)
                    elseif type(k) == "string" and k ~= "" and passive == true then
                        table.insert(selectedPassives, k)
                    end
                end
            end
        elseif type(vals) == "string" then
            table.insert(selectedPassives, vals)
        end
    end
    
    local count = #selectedPassives
    if count > 0 then
        Library:Notify("‚úÖ " .. count .. " passivas selecionadas: " .. table.concat(selectedPassives, ", "), 3)
    else
        Library:Notify("‚ö†Ô∏è Nenhuma passiva selecionada", 2)
    end
end)

-- Timing controls
LeftGroup:AddSlider("RollDelay", {
    Text = "Delay entre rolls (s)",
    Default = 1.0,
    Min = 0.1,
    Max = 3,
    Rounding = 1,
}):OnChanged(function(val)
    rollDelay = val
end)

LeftGroup:AddSlider("DetectionDelay", {
    Text = "Delay base detec√ß√£o (s)",
    Default = 2.5,
    Min = 1,
    Max = 8,
    Rounding = 1,
}):OnChanged(function(val)
    detectionConfig.baseDelay = val
end)

LeftGroup:AddSlider("MaxRetries", {
    Text = "Tentativas de detec√ß√£o",
    Default = 5,
    Min = 1,
    Max = 10,
    Rounding = 0,
}):OnChanged(function(val)
    detectionConfig.maxRetries = val
end)

-- MAIN AUTO ROLL TOGGLE
autoRollToggle = RightGroup:AddToggle("AutoRoll", {
    Text = "Start Auto Roll",
    Default = false,
})

autoRollToggle:OnChanged(function(val)
    if val then
        -- Validation
        if not selectedUnit then
            Library:Notify("‚ùå Selecione um boneco primeiro!", 3)
            autoRollToggle:SetValue(false)
            return
        end
        
        if not selectedPassives or not next(selectedPassives) then
            Library:Notify("‚ùå Selecione pelo menos uma passiva!", 3)
            autoRollToggle:SetValue(false)
            return
        end
        
        -- Start rolling
        rolling = true
        rollCount = 0
        detectionConfig.enabled = true
        rollStatusLabel:SetText("Status: üé≤ Iniciando...")
        
        -- DEBUG: Verificar passivas selecionadas antes de iniciar
        print("\nüöÄ === INICIANDO AUTO ROLL ===")
        print("üìã Passivas selecionadas para busca:")
        for i, passive in ipairs(selectedPassives) do
            print("  [" .. i .. "] " .. tostring(passive) .. " (tipo: " .. type(passive) .. ")")
        end
        print("üìä Total: " .. #selectedPassives .. " passivas")
        
        local passiveList = {}
        for _, p in pairs(selectedPassives) do
            table.insert(passiveList, tostring(p))
        end
        
        Library:Notify("üöÄ Auto Roll iniciado! Procurando: " .. table.concat(passiveList, ", "), 4)
        
        -- MAIN ROLLING LOOP
        task.spawn(function()
            while rolling do
                rollCount = rollCount + 1
                rollStatusLabel:SetText("Status: üé≤ Roll #" .. rollCount)
                
                print("\nüé≤ ========== ROLL #" .. rollCount .. " ==========")
                
                -- Execute roll
                local rollSuccess, rollError = pcall(function()
                    game:GetService("ReplicatedStorage").Remote.RollPassive:FireServer(
                        selectedUnit, selectedMachine, true, 1
                    )
                end)
                
                if not rollSuccess then
                    print("‚ùå Erro no roll: " .. tostring(rollError))
                    stopRolling("Erro no roll: " .. tostring(rollError))
                    break
                end
                
                print("‚úÖ Roll enviado com sucesso")
                print("‚è≥ Aguardando " .. detectionConfig.baseDelay .. "s para sincroniza√ß√£o...")
                
                -- Wait for server to process
                task.wait(detectionConfig.baseDelay)
                
                -- Check if still rolling
                if not rolling then 
                    print("üõë Sistema parado durante espera")
                    break 
                end
                
                -- Detect passives
                print("üîç Iniciando detec√ß√£o de passivas...")
                local found = detectDesiredPassive()
                
                if found then
                    print("üéâ ========== PASSIVA DESEJADA ENCONTRADA! ==========")
                    Library:Notify("üéâ PASSIVA ENCONTRADA! Sistema parado automaticamente!", 10)
                    stopRolling("Passiva desejada encontrada!")
                    break
                end
                
                -- Update display
                local unit = getCurrentUnit()
                updatePassiveDisplay(unit)
                
                -- Check again if still rolling
                if not rolling then 
                    print("üõë Sistema parado ap√≥s detec√ß√£o")
                    break 
                end
                
                -- Progress feedback
                if rollCount % 5 == 0 then
                    Library:Notify("üìä " .. rollCount .. " rolls realizados", 2)
                end
                
                -- Wait before next roll
                print("‚è≠Ô∏è Pr√≥ximo roll em " .. rollDelay .. "s...")
                task.wait(rollDelay)
            end
            
            rollStatusLabel:SetText("Status: ‚èπÔ∏è Parado")
            print("üîö Loop de rolling finalizado")
        end)
        
    else
        -- Stop rolling
        stopRolling("Parado pelo usu√°rio")
        rollStatusLabel:SetText("Status: ‚èπÔ∏è Parado")
    end
end)

-- Emergency stop
RightGroup:AddButton("Emergency Stop", function()
    stopRolling("Emergency stop")
    rollStatusLabel:SetText("Status: Stopped")
    Library:Notify("System stopped!", 2)
end)

-- ===== DEBUG FUNCTIONS =====

-- Show current passives
DebugGroup:AddButton("üîç Ver Passivas Atuais", function()
    if not selectedUnit then
        Library:Notify("‚ùå Selecione uma unit primeiro!", 2)
        return
    end
    
    local unit = getCurrentUnit()
    if unit then
        print("\n=== PASSIVAS DA UNIT " .. selectedUnit .. " ===")
        
        if unit.Passives and next(unit.Passives) then
            for i, passive in pairs(unit.Passives) do
                local passiveStr = passiveToString(passive)
                if passiveStr then
                    print("[" .. i .. "] " .. passiveStr .. " ‚úÖ")
                    
                    -- Validar no PassiveStats
                    if isValidPassive(passiveStr) then
                        print("    ‚îî‚îÄ V√°lida no PassiveStats ‚úÖ")
                    else
                        print("    ‚îî‚îÄ ‚ö†Ô∏è N√£o encontrada no PassiveStats")
                    end
                    
                    -- Test HasPassive if available
                    if HasPassive then
                        for _, desired in pairs(selectedPassives) do
                            if passiveStr == desired then
                                local hasIt = checkHasPassive(unit, desired)
                                print("    ‚îî‚îÄ HasPassive('" .. desired .. "') = " .. tostring(hasIt))
                            end
                        end
                    end
                else
                    print("[" .. i .. "] " .. tostring(passive) .. " ‚ùå (ignorado)")
                end
            end
        else
            print("‚ùå Nenhuma passiva encontrada")
        end
        print("=====================================")
        
        updatePassiveDisplay(unit)
    else
        print("‚ùå Unit n√£o encontrada!")
    end
    
    Library:Notify("üìã Informa√ß√µes no console", 2)
end)

-- Test detection without rolling
DebugGroup:AddButton("üß™ Testar Detec√ß√£o", function()
    if not selectedUnit or not selectedPassives or not next(selectedPassives) then
        Library:Notify("‚ùå Configure unit e passivas primeiro!", 2)
        return
    end
    
    print("\n=== TESTE DE DETEC√á√ÉO ===")
    detectionConfig.enabled = true
    
    local found = detectDesiredPassive()
    print("üéØ Resultado: " .. (found and "‚úÖ PASSIVA ENCONTRADA!" or "‚ùå Passiva n√£o encontrada"))
    
    detectionConfig.enabled = false
    print("========================")
    Library:Notify("üß™ Teste conclu√≠do - veja o console", 2)
end)

-- Single roll simulation
DebugGroup:AddButton("üéØ Roll √önico", function()
    if not selectedUnit then
        Library:Notify("‚ùå Selecione uma unit primeiro!", 2)
        return
    end
    
    print("\n=== ROLL √öNICO ===")
    
    local rollSuccess = pcall(function()
        game:GetService("ReplicatedStorage").Remote.RollPassive:FireServer(
            selectedUnit, selectedMachine, true, 1
        )
    end)
    
    if rollSuccess then
        print("‚úÖ Roll enviado com sucesso")
        Library:Notify("üéØ Roll √∫nico executado", 2)
        
        -- Auto-update display after delay
        task.spawn(function()
            task.wait(detectionConfig.baseDelay)
            local unit = getCurrentUnit()
            updatePassiveDisplay(unit)
            print("üîÑ Display atualizado")
        end)
    else
        print("‚ùå Erro no roll")
        Library:Notify("‚ùå Erro no roll √∫nico", 2)
    end
    
    print("==================")
end)

-- ===== INITIALIZATION =====

-- Theme and save managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)

-- Load units after initialization
task.spawn(function()
    task.wait(1)
    unitDropdown:SetValues(GetUnits())
end)

Library:Notify("üöÄ Auto Roll FINAL WORKING FIX v8.0 carregado com sucesso!", 4)
print("üéØ Auto Roll FINAL WORKING FIX v8.0 - Sistema otimizado com base no seu feedback!")
