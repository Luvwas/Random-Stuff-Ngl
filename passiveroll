local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/Library.lua"))()
local ThemeManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/addons/SaveManager.lua"))()

local AllPassives = {
    ["Normal"] = {
        "Dmg1", "Dmg2", "Dmg3",
        "Boss1", "Boss2", "Boss3", 
        "Drop1", "Drop2", "Drop3",
        "Yen1", "Yen2", "Yen3",
        "LevelUp1", "LevelUp2", "LevelUp3",
        "Ability1", "Ability2", "Ability3",
        "Leader1", "Leader2", "Leader3",
        "Luck1", "Luck2", "Luck3", "Luck4",
        "Cap1", "Cap2", "Cap3",
        "Speed", "Giant", "Tiny", "Tank", "Blessing",
        "Gold", "Merc", "Dragon", "Prodigy", "Ghost", "Ace",
        "Demon", "BrokenLimiter", "Angel", "Interstellar"
    },
    ["Summer24"] = {
        "SeaSpearman", "DevastatingDaylight", "SummerFortune",
        "SapphireSummer", "SummerGenerosity", "ShiningSun", "CoralCommander"
    }
}
AllPassives["Requiem"] = AllPassives["Normal"]

-- Store initialization
local LocalDairebStore, GameData
local success, error = pcall(function()
    LocalDairebStore = require(game:GetService("ReplicatedStorage").ModuleScripts.LocalDairebStore)
    LocalDairebStore:WaitForInit()
    GameData = LocalDairebStore.GetStoreProxy("GameData")
end)

if not success then
    Library:Notify("‚ùå Erro ao carregar GameData: " .. tostring(error), 10)
    return
end

-- HasPassive module (optional)
local HasPassive = nil
pcall(function()
    HasPassive = require(game:GetService("ReplicatedStorage").ModuleScripts.HasPassive)
end)

-- PassiveStats module for validation
local PassiveStats = nil
pcall(function()
    PassiveStats = require(game:GetService("ReplicatedStorage").ModuleScripts.PassiveStats)
end)

-- Global variables
local selectedUnit, selectedMachine = nil, "Normal"
local selectedPassives = {}
local rolling = false
local rollDelay = 1.0
local rollCount = 0
local autoRollToggle = nil

-- MULTI-UNIT SYSTEM üî•
local multiUnitQueue = {}
local multiUnitRolling = false
local currentUnitIndex = 1
local multiUnitToggle = nil
local queueLabel = nil

-- Log system
local passiveLog = {}
local logLabel = nil

-- Detection configuration - OTIMIZADO para m√°xima velocidade
local detectionConfig = {
    baseDelay = 1.5,        -- Delay inicial ainda mais reduzido
    maxRetries = 3,         -- Menos tentativas para mais velocidade
    retryDelay = 0.5,       -- Delay menor entre tentativas
    enabled = false
}

-- ===== CORE FUNCTIONS =====

-- Get current unit data - MELHORADO
local function getCurrentUnit()
    local success, result = pcall(function()
        local gameData = GameData:GetData()
        if not gameData or not gameData.Pets then return nil end
        
        for _, unit in pairs(gameData.Pets) do
            if unit and unit.UID == selectedUnit then
                return unit
            end
        end
        return nil
    end)
    
    return success and result or nil
end

-- NOVA FUN√á√ÉO: Validar se passiva existe no PassiveStats
local function isValidPassive(passiveName)
    if not PassiveStats or not passiveName then return false end
    return PassiveStats[passiveName] ~= nil
end

-- FUN√á√ÉO MELHORADA: Convers√£o de passiva mais permissiva
local function passiveToString(passive)
    if passive == nil then return nil end
    
    -- Aceitar strings diretamente
    if type(passive) == "string" and passive ~= "" and passive ~= "nil" then 
        return passive 
    end
    
    -- Converter n√∫meros
    if type(passive) == "number" then 
        return tostring(passive) 
    end
    
    -- Tentar converter outros tipos
    local str = tostring(passive)
    if str and str ~= "" and str ~= "nil" and str ~= "false" and str ~= "true" then
        return str
    end
    
    return nil
end

-- FUN√á√ÉO MELHORADA: HasPassive com mais m√©todos
local function checkHasPassive(unit, passiveName)
    if not HasPassive or not unit or not passiveName then 
        return false 
    end
    
    -- Lista de m√©todos poss√≠veis para tentar
    local methods = {
        -- M√©todo direto
        function() return HasPassive(unit, passiveName) end,
        -- M√©todo com .HasPassive
        function() return HasPassive.HasPassive(unit, passiveName) end,
        -- M√©todo com .Check
        function() return HasPassive.Check(unit, passiveName) end,
        -- M√©todo com UID
        function() return HasPassive(unit.UID, passiveName) end,
        -- M√©todo com passiva como objeto
        function() 
            if unit.Passives then
                for _, passive in pairs(unit.Passives) do
                    if passiveToString(passive) == passiveName then
                        return HasPassive(unit, passive)
                    end
                end
            end
            return false
        end
    }
    
    for i, method in ipairs(methods) do
        local success, result = pcall(method)
        if success and result then
            print("‚úÖ HasPassive m√©todo " .. i .. " encontrou: " .. passiveName)
            return true
        end
    end
    
    return false
end

-- FUN√á√ÉO MELHORADA: Detec√ß√£o manual mais robusta
local function checkPassivesManual(unit, desiredPassives)
    if not unit or not unit.Passives or not desiredPassives then 
        return false, nil 
    end
    
    local currentPassives = {}
    
    for i, passive in pairs(unit.Passives) do
        local passiveStr = passiveToString(passive)
        if passiveStr then
            currentPassives[passiveStr] = true
        end
    end
    
    for _, desired in pairs(desiredPassives) do
        local desiredStr = tostring(desired)
        
        if currentPassives[desiredStr] then
            return true, desiredStr
        end
        
        for currentPassive, _ in pairs(currentPassives) do
            if string.lower(currentPassive) == string.lower(desiredStr) then
                return true, currentPassive
            end
        end
        
        for currentPassive, _ in pairs(currentPassives) do
            if string.find(string.lower(currentPassive), string.lower(desiredStr)) or 
               string.find(string.lower(desiredStr), string.lower(currentPassive)) then
                return true, currentPassive
            end
        end
    end
    
    return false, nil
end

-- FUN√á√ÉO PRINCIPAL: Detec√ß√£o com retry melhorado
local function detectDesiredPassive()
    if not detectionConfig.enabled or not selectedUnit or not selectedPassives or not next(selectedPassives) then
        return false, nil
    end
    
    for attempt = 1, detectionConfig.maxRetries do
        local currentUnit = getCurrentUnit()
        if not currentUnit then
            task.wait(detectionConfig.retryDelay)
            continue
        end
        
        if HasPassive then
            for _, desiredPassive in pairs(selectedPassives) do
                if checkHasPassive(currentUnit, desiredPassive) then
                    return true, desiredPassive
                end
            end
        end
        
        local found, foundPassive = checkPassivesManual(currentUnit, selectedPassives)
        if found then
            return true, foundPassive
        end
        
        if attempt < detectionConfig.maxRetries then
            task.wait(detectionConfig.retryDelay)
        end
    end
    
    return false, nil
end

-- Log system functions
local function addToLog(passiveName, rollsUsed, unitName)
    local timestamp = os.date("%H:%M:%S")
    local unitDisplay = unitName or "Unit"
    local logEntry = string.format("[%s] %s: %s ap√≥s %d rolls", timestamp, unitDisplay, passiveName, rollsUsed)
    table.insert(passiveLog, logEntry)
    
    -- Keep only last 50 entries for scrollable display
    if #passiveLog > 50 then
        table.remove(passiveLog, 1)
    end
    
    -- Update log display with scrollable formatting
    if logLabel then
        local displayText = "üìã Log de Passivas (" .. #passiveLog .. "/50):\n"
        
        -- Show last 20 entries for better visibility
        local startIndex = math.max(1, #passiveLog - 19)
        for i = startIndex, #passiveLog do
            displayText = displayText .. passiveLog[i] .. "\n"
        end
        
        if #passiveLog > 20 then
            displayText = "‚¨ÜÔ∏è (" .. (#passiveLog - 20) .. " entradas anteriores)\n" .. displayText
        end
        
        pcall(function() logLabel:SetText(displayText) end)
    end
end

local function clearLog()
    passiveLog = {}
    if logLabel then
        pcall(function() logLabel:SetText("üìã Log de Passivas (0/50):\n(Nenhuma passiva registrada)") end)
    end
end

-- Stop the rolling system
local function stopRolling(reason, foundPassive)
    rolling = false
    detectionConfig.enabled = false
    
    -- Add to log if a passive was found
    if foundPassive and rollCount > 0 then
        addToLog(foundPassive, rollCount)
    end
    
    if autoRollToggle then
        pcall(function() autoRollToggle:SetValue(false) end)
    end
    
    print("üõë PARADO: " .. tostring(reason))
    Library:Notify("üõë " .. reason, 5)
end

-- Update passive display in UI
local function updatePassiveDisplay(unit)
    if not unit or not unit.Passives then
        pcall(function() currentPassivesLabel:SetText("Passivas: N/A") end)
        return
    end
    
    local passiveList = {}
    for _, passive in pairs(unit.Passives) do
        local passiveStr = passiveToString(passive)
        if passiveStr then
            table.insert(passiveList, passiveStr)
        end
    end
    
    local displayText = "Passivas: " .. (#passiveList > 0 and table.concat(passiveList, ", ") or "Nenhuma")
    pcall(function() currentPassivesLabel:SetText(displayText) end)
end

-- Get list of available units
local function GetUnits()
    local success, result = pcall(function()
        local gameData = GameData:GetData()
        if not gameData or not gameData.Pets then
            return {"Nenhum pet encontrado"}
        end
            
        local list = {}
        for _, unit in pairs(gameData.Pets) do
            if unit and unit.UID then
                local displayName = unit.PetId or "Unknown"
                if unit.CustomName and unit.CustomName ~= "" then
                    displayName = displayName .. " (" .. unit.CustomName .. ")"
                end
                table.insert(list, tostring(unit.UID) .. " | " .. displayName)
            end
        end
        
        return #list > 0 and list or {"Nenhum pet encontrado"}
    end)
    
    return success and result or {"Erro ao carregar pets"}
end

-- ===== MULTI-UNIT FUNCTIONS üî• =====

-- Get unit by UID
local function getUnitByUID(uid)
    local success, result = pcall(function()
        local gameData = GameData:GetData()
        if not gameData or not gameData.Pets then return nil end
        
        for _, unit in pairs(gameData.Pets) do
            if unit and unit.UID == uid then
                return unit
            end
        end
        return nil
    end)
    
    return success and result or nil
end

-- Get unit display name
local function getUnitDisplayName(uid)
    local unit = getUnitByUID(uid)
    if not unit then return "Unit " .. tostring(uid) end
    
    local displayName = unit.PetId or "Unknown"
    if unit.CustomName and unit.CustomName ~= "" then
        displayName = unit.CustomName
    end
    return displayName
end

-- Update queue display
local function updateQueueDisplay()
    if not queueLabel then return end
    
    local queueText = "üéØ Fila Multi-Unit (0/15):\n"
    
    -- Show current queue items
    for i, unitData in ipairs(multiUnitQueue) do
        local status = ""
        if i == currentUnitIndex and multiUnitRolling then
            status = " üé≤"
        elseif unitData.completed then
            status = " ‚úÖ"
        else
            status = " ‚è≥"
        end
        queueText = queueText .. string.format("%d. %s%s\n", i, getUnitDisplayName(unitData.uid), status)
    end
    
    -- Add empty slots to show 15 total
    local emptySlots = 15 - #multiUnitQueue
    for i = #multiUnitQueue + 1, 15 do
        queueText = queueText .. string.format("%d. [Vazio]\n", i)
    end
    
    -- Update the count in header
    queueText = queueText:gsub("%(0/15%)", "(" .. #multiUnitQueue .. "/15)")
    
    pcall(function() queueLabel:SetText(queueText) end)
end

-- Add unit to queue
local function addUnitToQueue()
    if not selectedUnit then
        Library:Notify("‚ùå Selecione um boneco primeiro!", 3)
        return
    end
    
    -- Check if unit already in queue
    for _, unitData in ipairs(multiUnitQueue) do
        if unitData.uid == selectedUnit then
            Library:Notify("‚ö†Ô∏è Este boneco j√° est√° na fila!", 3)
            return
        end
    end
    
    local unitName = getUnitDisplayName(selectedUnit)
    table.insert(multiUnitQueue, {
        uid = selectedUnit,
        name = unitName,
        completed = false
    })
    
    updateQueueDisplay()
    Library:Notify("‚úÖ " .. unitName .. " adicionado √† fila! Total: " .. #multiUnitQueue, 3)
end

-- Remove unit from queue
local function removeUnitFromQueue(index)
    if index and multiUnitQueue[index] then
        local unitName = multiUnitQueue[index].name
        table.remove(multiUnitQueue, index)
        
        -- Adjust current index if needed
        if currentUnitIndex > index then
            currentUnitIndex = currentUnitIndex - 1
        elseif currentUnitIndex == index and multiUnitRolling then
            -- If we removed the current unit, stop rolling
            multiUnitRolling = false
        end
        
        updateQueueDisplay()
        Library:Notify("üóëÔ∏è " .. unitName .. " removido da fila!", 2)
    end
end

-- Clear queue
local function clearQueue()
    multiUnitQueue = {}
    currentUnitIndex = 1
    updateQueueDisplay()
    Library:Notify("üóëÔ∏è Fila limpa!", 2)
end

-- Stop multi-unit rolling
local function stopMultiUnitRolling(reason, foundPassive, unitName)
    multiUnitRolling = false
    rolling = false
    detectionConfig.enabled = false
    
    -- Add to log if a passive was found
    if foundPassive and rollCount > 0 then
        addToLog(foundPassive, rollCount, unitName)
    end
    
    if multiUnitToggle then
        pcall(function() multiUnitToggle:SetValue(false) end)
    end
    
    updateQueueDisplay()
    print("üõë MULTI-UNIT PARADO: " .. tostring(reason))
    Library:Notify("üõë Multi-Unit: " .. reason, 5)
end

-- ===== UI SETUP =====

local Window = Library:CreateWindow({ 
    Title = "Luvwas Passive Roll", 
    Center = true, 
    AutoShow = true 
})

local Tabs = { 
    Main = Window:AddTab("Main"),
    MultiUnit = Window:AddTab("Multi-Unit"),
    Debug = Window:AddTab("Debug"),
    Settings = Window:AddTab("Settings")
}

local LeftGroup = Tabs.Main:AddLeftGroupbox("Configura√ß√£o")
local RightGroup = Tabs.Main:AddRightGroupbox("Controles")
local StatusGroup = Tabs.Main:AddRightGroupbox("Status")

-- Extended Debug groups for longer display
local DebugGroup = Tabs.Debug:AddLeftGroupbox("Debug & Test")
local LogGroup = Tabs.Debug:AddRightGroupbox("Passive Log")

-- MULTI-UNIT TAB üî•
local MultiLeftGroup = Tabs.MultiUnit:AddLeftGroupbox("Gerenciar Fila")
local MultiRightGroup = Tabs.MultiUnit:AddRightGroupbox("Controle Multi-Unit")

-- Status indicators
StatusGroup:AddLabel("GameData: " .. (GameData and "‚úÖ OK" or "‚ùå Erro"))
StatusGroup:AddLabel("HasPassive: " .. (HasPassive and "‚úÖ Dispon√≠vel" or "‚ö†Ô∏è Manual apenas"))
StatusGroup:AddLabel("PassiveStats: " .. (PassiveStats and "‚úÖ Dispon√≠vel" or "‚ö†Ô∏è N√£o dispon√≠vel"))
local rollStatusLabel = StatusGroup:AddLabel("Status: Aguardando")
local currentPassivesLabel = StatusGroup:AddLabel("Passivas: N/A")

-- Unit selection
local unitDropdown = LeftGroup:AddDropdown("UnitSelect", {
    Values = GetUnits(),
    Multi = false,
    Text = "Selecione o Boneco",
    AllowNull = true,
    Search = true,
})

unitDropdown:OnChanged(function(val)
    if val and not val:find("Erro") and not val:find("Nenhum") then
        selectedUnit = tonumber(val:match("^(%d+)"))
        Library:Notify("‚úÖ Unit selecionada: " .. tostring(selectedUnit), 2)
        
        -- Show current passives
        local unit = getCurrentUnit()
        updatePassiveDisplay(unit)
    else
        selectedUnit = nil
        pcall(function() currentPassivesLabel:SetText("Passivas: N/A") end)
    end
end)

LeftGroup:AddButton("üîÑ Atualizar Lista", function()
    unitDropdown:SetValues(GetUnits())
end)

-- Machine selection
local machineDropdown = LeftGroup:AddDropdown("MachineSelect", {
    Values = {"Normal","Requiem","Summer24"},
    Default = "Normal",
    Multi = false,
    Text = "M√°quina",
})

-- Passive selection
local passiveDropdown = LeftGroup:AddDropdown("PassiveSelect", {
    Values = AllPassives["Normal"],
    Default = {},
    Multi = true,
    Text = "Passivas Desejadas",
})

machineDropdown:OnChanged(function(val)
    selectedMachine = val
    passiveDropdown:SetValues(AllPassives[val] or AllPassives["Normal"])
    passiveDropdown:SetValue({})
    selectedPassives = {}
    print("üîÑ M√°quina alterada para: " .. val)
end)

passiveDropdown:OnChanged(function(vals)
    selectedPassives = {}
    
    if vals then
        if type(vals) == "table" then
            -- M√©todo 1: ipairs
            for i, passive in ipairs(vals) do
                if type(passive) == "string" and passive ~= "" then
                    table.insert(selectedPassives, passive)
                end
            end
            
            -- M√©todo 2: pairs (caso ipairs n√£o funcione)
            if #selectedPassives == 0 then
                for k, passive in pairs(vals) do
                    if type(passive) == "string" and passive ~= "" then
                        table.insert(selectedPassives, passive)
                    elseif type(k) == "string" and k ~= "" and passive == true then
                        table.insert(selectedPassives, k)
                    end
                end
            end
        elseif type(vals) == "string" then
            table.insert(selectedPassives, vals)
        end
    end
    
    local count = #selectedPassives
    if count > 0 then
        Library:Notify("‚úÖ " .. count .. " passivas selecionadas: " .. table.concat(selectedPassives, ", "), 3)
    else
        Library:Notify("‚ö†Ô∏è Nenhuma passiva selecionada", 2)
    end
end)

-- Timing controls
LeftGroup:AddSlider("RollDelay", {
    Text = "Delay entre rolls (s)",
    Default = 1.0,
    Min = 0.1,
    Max = 3,
    Rounding = 1,
}):OnChanged(function(val)
    rollDelay = val
end)

LeftGroup:AddSlider("DetectionDelay", {
    Text = "Delay base detec√ß√£o (s)",
    Default = 1.5,
    Min = 0.5,
    Max = 8,
    Rounding = 1,
}):OnChanged(function(val)
    detectionConfig.baseDelay = val
end)

LeftGroup:AddSlider("MaxRetries", {
    Text = "Tentativas de detec√ß√£o",
    Default = 3,
    Min = 1,
    Max = 10,
    Rounding = 0,
}):OnChanged(function(val)
    detectionConfig.maxRetries = val
end)

-- MAIN AUTO ROLL TOGGLE
autoRollToggle = RightGroup:AddToggle("AutoRoll", {
    Text = "Start Auto Roll",
    Default = false,
})

autoRollToggle:OnChanged(function(val)
    if val then
        -- Validation
        if not selectedUnit then
            Library:Notify("‚ùå Selecione um boneco primeiro!", 3)
            autoRollToggle:SetValue(false)
            return
        end
        
        if not selectedPassives or not next(selectedPassives) then
            Library:Notify("‚ùå Selecione pelo menos uma passiva!", 3)
            autoRollToggle:SetValue(false)
            return
        end
        
        -- Start rolling
        rolling = true
        rollCount = 0
        detectionConfig.enabled = true
        rollStatusLabel:SetText("Status: üé≤ Iniciando...")
        
        -- DEBUG: Verificar passivas selecionadas antes de iniciar
        print("\nüöÄ === INICIANDO AUTO ROLL ===")
        print("üìã Passivas selecionadas para busca:")
        for i, passive in ipairs(selectedPassives) do
            print("  [" .. i .. "] " .. tostring(passive) .. " (tipo: " .. type(passive) .. ")")
        end
        print("üìä Total: " .. #selectedPassives .. " passivas")
        
        local passiveList = {}
        for _, p in pairs(selectedPassives) do
            table.insert(passiveList, tostring(p))
        end
        
        Library:Notify("üöÄ Auto Roll iniciado! Procurando: " .. table.concat(passiveList, ", "), 4)
        
        -- MAIN ROLLING LOOP
        task.spawn(function()
            while rolling do
                rollCount = rollCount + 1
                rollStatusLabel:SetText("Status: üé≤ Roll #" .. rollCount)
                
                print("\nüé≤ ========== ROLL #" .. rollCount .. " ==========")
                
                -- Execute roll
                local rollSuccess, rollError = pcall(function()
                    game:GetService("ReplicatedStorage").Remote.RollPassive:FireServer(
                        selectedUnit, selectedMachine, true, 1
                    )
                end)
                
                if not rollSuccess then
                    print("‚ùå Erro no roll: " .. tostring(rollError))
                    stopRolling("Erro no roll: " .. tostring(rollError))
                    break
                end
                
                print("‚úÖ Roll enviado com sucesso")
                print("‚è≥ Aguardando " .. detectionConfig.baseDelay .. "s para sincroniza√ß√£o...")
                
                -- Wait for server to process
                task.wait(detectionConfig.baseDelay)
                
                -- Check if still rolling
                if not rolling then 
                    print("üõë Sistema parado durante espera")
                    break 
                end
                
                -- Detect passives
                print("üîç Iniciando detec√ß√£o de passivas...")
                local found, foundPassive = detectDesiredPassive()
                
                if found then
                    print("üéâ ========== PASSIVA DESEJADA ENCONTRADA! ==========")
                    Library:Notify("üéâ PASSIVA ENCONTRADA: " .. foundPassive .. "! Sistema parado automaticamente!", 10)
                    stopRolling("Passiva desejada encontrada!", foundPassive)
                    break
                end
                
                -- Update display
                local unit = getCurrentUnit()
                updatePassiveDisplay(unit)
                
                -- Check again if still rolling
                if not rolling then 
                    print("üõë Sistema parado ap√≥s detec√ß√£o")
                    break 
                end
                
                -- Progress feedback
                if rollCount % 5 == 0 then
                    Library:Notify("üìä " .. rollCount .. " rolls realizados", 2)
                end
                
                -- Wait before next roll
                print("‚è≠Ô∏è Pr√≥ximo roll em " .. rollDelay .. "s...")
                task.wait(rollDelay)
            end
            
            rollStatusLabel:SetText("Status: ‚èπÔ∏è Parado")
            print("üîö Loop de rolling finalizado")
        end)
        
    else
        -- Stop rolling
        stopRolling("Parado pelo usu√°rio")
        rollStatusLabel:SetText("Status: ‚èπÔ∏è Parado")
    end
end)

-- Emergency stop
RightGroup:AddButton("Emergency Stop", function()
    stopRolling("Emergency stop")
    rollStatusLabel:SetText("Status: Stopped")
    Library:Notify("System stopped!", 2)
end)

-- ===== DEBUG FUNCTIONS =====

-- Show current passives
DebugGroup:AddButton("üîç Ver Passivas Atuais", function()
    if not selectedUnit then
        Library:Notify("‚ùå Selecione uma unit primeiro!", 2)
        return
    end
    
    local unit = getCurrentUnit()
    if unit then
        print("\n=== PASSIVAS DA UNIT " .. selectedUnit .. " ===")
        
        if unit.Passives and next(unit.Passives) then
            for i, passive in pairs(unit.Passives) do
                local passiveStr = passiveToString(passive)
                if passiveStr then
                    print("[" .. i .. "] " .. passiveStr .. " ‚úÖ")
                    
                    -- Validar no PassiveStats
                    if isValidPassive(passiveStr) then
                        print("    ‚îî‚îÄ V√°lida no PassiveStats ‚úÖ")
                    else
                        print("    ‚îî‚îÄ ‚ö†Ô∏è N√£o encontrada no PassiveStats")
                    end
                    
                    -- Test HasPassive if available
                    if HasPassive then
                        for _, desired in pairs(selectedPassives) do
                            if passiveStr == desired then
                                local hasIt = checkHasPassive(unit, desired)
                                print("    ‚îî‚îÄ HasPassive('" .. desired .. "') = " .. tostring(hasIt))
                            end
                        end
                    end
                else
                    print("[" .. i .. "] " .. tostring(passive) .. " ‚ùå (ignorado)")
                end
            end
        else
            print("‚ùå Nenhuma passiva encontrada")
        end
        print("=====================================")
        
        updatePassiveDisplay(unit)
    else
        print("‚ùå Unit n√£o encontrada!")
    end
    
    Library:Notify("üìã Informa√ß√µes no console", 2)
end)

-- Test detection without rolling
DebugGroup:AddButton("üß™ Testar Detec√ß√£o", function()
    if not selectedUnit or not selectedPassives or not next(selectedPassives) then
        Library:Notify("‚ùå Configure unit e passivas primeiro!", 2)
        return
    end
    
    print("\n=== TESTE DE DETEC√á√ÉO ===")
    detectionConfig.enabled = true
    
    local found = detectDesiredPassive()
    print("üéØ Resultado: " .. (found and "‚úÖ PASSIVA ENCONTRADA!" or "‚ùå Passiva n√£o encontrada"))
    
    detectionConfig.enabled = false
    print("========================")
    Library:Notify("üß™ Teste conclu√≠do - veja o console", 2)
end)

-- Single roll simulation
DebugGroup:AddButton("üéØ Roll √önico", function()
    if not selectedUnit then
        Library:Notify("‚ùå Selecione uma unit primeiro!", 2)
        return
    end
    
    print("\n=== ROLL √öNICO ===")
    
    local rollSuccess = pcall(function()
        game:GetService("ReplicatedStorage").Remote.RollPassive:FireServer(
            selectedUnit, selectedMachine, true, 1
        )
    end)
    
    if rollSuccess then
        print("‚úÖ Roll enviado com sucesso")
        Library:Notify("üéØ Roll √∫nico executado", 2)
        
        -- Auto-update display after delay
        task.spawn(function()
            task.wait(detectionConfig.baseDelay)
            local unit = getCurrentUnit()
            updatePassiveDisplay(unit)
            print("üîÑ Display atualizado")
        end)
    else
        print("‚ùå Erro no roll")
        Library:Notify("‚ùå Erro no roll √∫nico", 2)
    end
    
    print("==================")
end)

DebugGroup:AddDivider()
DebugGroup:AddButton("üìä Status do Sistema", function()
    print("\n=== STATUS DO SISTEMA ===")
    print("üéØ Unit selecionada: " .. tostring(selectedUnit))
    print("üé∞ M√°quina: " .. selectedMachine)
    print("üìã Passivas selecionadas: " .. #selectedPassives)
    for i, p in ipairs(selectedPassives) do
        print("  [" .. i .. "] " .. p)
    end
    print("üé≤ Rolling ativo: " .. tostring(rolling))
    print("üîç Detec√ß√£o ativada: " .. tostring(detectionConfig.enabled))
    print("üìä Total de rolls: " .. rollCount)
    print("========================")
    Library:Notify("üìä Status exibido no console", 2)
end)

-- ===== MULTI-UNIT TAB UI =====

-- Add unit to queue button
MultiLeftGroup:AddButton("‚ûï Adicionar Personagem √† Fila", function()
    addUnitToQueue()
end)

MultiLeftGroup:AddDivider()

-- Queue display with extended height - shows all 15 slots
queueLabel = MultiLeftGroup:AddLabel("üéØ Fila Multi-Unit (0/15):\n1. [Vazio]\n2. [Vazio]\n3. [Vazio]\n4. [Vazio]\n5. [Vazio]\n6. [Vazio]\n7. [Vazio]\n8. [Vazio]\n9. [Vazio]\n10. [Vazio]\n11. [Vazio]\n12. [Vazio]\n13. [Vazio]\n14. [Vazio]\n15. [Vazio]")

MultiLeftGroup:AddDivider()

-- Queue management buttons
MultiLeftGroup:AddButton("üóëÔ∏è Limpar Fila", function()
    clearQueue()
end)

-- Multi-unit controls
multiUnitToggle = MultiRightGroup:AddToggle("MultiUnitRoll", {
    Text = "üöÄ Start Multi-Unit Roll",
    Default = false,
})

-- Multi-unit rolling logic
multiUnitToggle:OnChanged(function(val)
    if val then
        -- Validation
        if #multiUnitQueue == 0 then
            Library:Notify("‚ùå Adicione pelo menos um personagem √† fila!", 3)
            multiUnitToggle:SetValue(false)
            return
        end
        
        if not selectedPassives or not next(selectedPassives) then
            Library:Notify("‚ùå Selecione pelo menos uma passiva na aba Main!", 3)
            multiUnitToggle:SetValue(false)
            return
        end
        
        -- Start multi-unit rolling
        multiUnitRolling = true
        rolling = true
        currentUnitIndex = 1
        rollCount = 0
        detectionConfig.enabled = true
        
        Library:Notify("üöÄ Multi-Unit iniciado! Processando " .. #multiUnitQueue .. " personagens", 4)
        
        -- MULTI-UNIT ROLLING LOOP
        task.spawn(function()
            while multiUnitRolling and currentUnitIndex <= #multiUnitQueue do
                local currentUnitData = multiUnitQueue[currentUnitIndex]
                if not currentUnitData or currentUnitData.completed then
                    currentUnitIndex = currentUnitIndex + 1
                    continue
                end
                
                -- Set current unit
                selectedUnit = currentUnitData.uid
                local unitName = getUnitDisplayName(currentUnitData.uid)
                
                print("\nüéØ === PROCESSANDO UNIT: " .. unitName .. " ===")
                Library:Notify("üé≤ Processando: " .. unitName, 3)
                
                updateQueueDisplay()
                
                -- Roll for this unit until passive found or stopped
                local unitRollCount = 0
                while multiUnitRolling and not currentUnitData.completed do
                    unitRollCount = unitRollCount + 1
                    rollCount = rollCount + 1
                    
                    print("\nüé≤ ========== " .. unitName .. " - ROLL #" .. unitRollCount .. " ==========")
                    
                    -- Execute roll
                    local rollSuccess, rollError = pcall(function()
                        game:GetService("ReplicatedStorage").Remote.RollPassive:FireServer(
                            currentUnitData.uid, selectedMachine, true, 1
                        )
                    end)
                    
                    if not rollSuccess then
                        print("‚ùå Erro no roll: " .. tostring(rollError))
                        stopMultiUnitRolling("Erro no roll: " .. tostring(rollError))
                        break
                    end
                    
                    print("‚úÖ Roll enviado com sucesso")
                    
                    -- Wait for server to process
                    task.wait(detectionConfig.baseDelay)
                    
                    if not multiUnitRolling then break end
                    
                    -- Detect passives
                    print("üîç Iniciando detec√ß√£o de passivas...")
                    local found, foundPassive = detectDesiredPassive()
                    
                    if found then
                        print("üéâ ========== PASSIVA ENCONTRADA EM " .. unitName .. "! ==========")
                        Library:Notify("üéâ " .. unitName .. " pegou " .. foundPassive .. "! Continuando com pr√≥ximo...", 5)
                        
                        -- Mark unit as completed and remove from queue
                        currentUnitData.completed = true
                        addToLog(foundPassive, unitRollCount, unitName)
                        
                        -- Remove completed unit from queue
                        for i, unit in ipairs(multiUnitQueue) do
                            if unit.uid == currentUnitData.uid then
                                table.remove(multiUnitQueue, i)
                                -- Adjust current index since we removed an item
                                if currentUnitIndex > i then
                                    currentUnitIndex = currentUnitIndex - 1
                                elseif currentUnitIndex == i then
                                    -- Don't increment currentUnitIndex, it will point to next unit automatically
                                    currentUnitIndex = currentUnitIndex - 1
                                end
                                break
                            end
                        end
                        
                        updateQueueDisplay()
                        
                        -- Exit loop for this unit
                        print("‚úÖ " .. unitName .. " completado! Passando para pr√≥ximo personagem...")
                        break
                    end
                    
                    -- Progress feedback
                    if unitRollCount % 3 == 0 then
                        Library:Notify("üìä " .. unitName .. ": " .. unitRollCount .. " rolls", 2)
                    end
                    
                    -- Wait before next roll
                    task.wait(rollDelay)
                end
                
                -- Move to next unit if current is completed or stopped
                if currentUnitData.completed or not multiUnitRolling then
                    currentUnitIndex = currentUnitIndex + 1
                end
            end
            
            -- Check if all units completed
            if #multiUnitQueue == 0 then
                Library:Notify("üéâ Todos os personagens completaram! Sistema parado.", 8)
                stopMultiUnitRolling("Todos os personagens completaram!")
            else
                Library:Notify("üõë Multi-Unit parado", 3)
                multiUnitRolling = false
                rolling = false
                detectionConfig.enabled = false
                if multiUnitToggle then
                    pcall(function() multiUnitToggle:SetValue(false) end)
                end
            end
            
            updateQueueDisplay()
            print("üîö Multi-Unit loop finalizado")
        end)
        
    else
        -- Stop multi-unit rolling
        stopMultiUnitRolling("Parado pelo usu√°rio")
    end
end)

MultiRightGroup:AddButton("‚èπÔ∏è Emergency Stop Multi-Unit", function()
    stopMultiUnitRolling("Emergency stop")
    Library:Notify("üõë Multi-Unit parado!", 2)
end)

-- ===== LOG SYSTEM UI =====

-- Log display with scrollable format - shows last 20 entries
logLabel = LogGroup:AddLabel("üìã Log de Passivas (0/50):\n(Nenhuma passiva registrada)")

-- Clear log button
LogGroup:AddButton("üóëÔ∏è Limpar Log", function()
    clearLog()
    Library:Notify("üìã Log limpo!", 2)
end)

-- ===== INITIALIZATION =====

-- Initialize queue display
updateQueueDisplay()

-- Theme and save managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)

-- Load units after initialization
task.spawn(function()
    task.wait(1)
    unitDropdown:SetValues(GetUnits())
end)

Library:Notify("Auto Roll Multi-Unit carregado", 3)
